[!System Design]
[#systemdesign]
***
## Ограничение числа запросов 
- HTTP 429 слишком много запросов
- алгоритм маркерной корзины (token bucket);
    Маркерная корзина — это контейнер с заранее определенной емкостью. 
    В нее регулярно помещают маркеры - например каждую секунду определенное количество. 
    Когда она окончательно заполняется, маркеры больше не добавляются. 
    Каждый запрос потребляет один маркер. 
    Если маркеров достаточно, мы удаляем по одному из них для каждого запроса, и запрос проходит дальше;
    Eсли маркеров недостаточно, запрос отклоняется.
    * может справиться с короткими всплесками трафика
- алгоритм дырявого ведра (leaking bucket);
    при поступлении запроса система проверяет, заполнена ли очередь.
    Запрос добавляется в очередь при наличии места
    в противном случае запрос отклоняется;
    запросы извлекаются из очереди и обрабатываются через равные промежутки времени.
- счетчик фиксированных интервалов (fixed window counter);
    Алгоритм делит заданный период времени на одинаковые интервалы и назначает каждому из них счетчик.
    Каждый запрос инкрементирует счетчик на 1.
    Как только счетчик достигнет заранее заданного лимита, новые запросы начинают отклоняться, 
    пока не начнется следующий интервал.
- журнал скользящих интервалов (sliding window log);
    потребляет много памяти
- счетчик скользящих интервалов (sliding window counter).

X Базу данных лучше не использовать для счетчиков.

### Реализация
резидентный кэш - Redis
INCR увеличивает хранимый счетчик на 1.
EXPIRE устанавливает срок хранения счетчика, по истечении которого тот автоматически удаляется

Клиент шлет запрос промежуточному ограничителю трафика.
Промежуточный ограничитель трафика извлекает счетчик из соответствующего бакета Redis и проверяет, достигнут ли лимит.
	- Если лимит достигнут, запрос отклоняется.
	- Если лимит не достигнут, запрос направляется серверам API.
Тем временем система инкрементирует счетчик и сохраняет его обратно в Redis

Config - Правила обычно записываются в конфигурационные файлы и сохраняются на диске.

### Ограничитель трафика возвращает клиентам следующие HTTP-заголовки:
X-Ratelimit-Remaining. Количество допустимых запросов, которое остается в текущем интервале.
X-Ratelimit-Limit. Количество вызовов, доступных клиенту в каждом временном интервале.
X-Ratelimit-Retry-After. Количество секунд, которое должно пройти, прежде чем ваши запросы престанут отклоняться.	

На распределенных системах может быть гонка с записью в редис - борьба через «упорядоченные множества», доступную в Redis 
***
## СОГЛАСОВАННОЕ ХЕШИРОВАНИЕ
serverIndex = hash(key) % N, где N — размер пула серверов	
«Согласованное хеширование (англ. consistent hashing)
проблема когда один из серверов выпадает - надо перестравиать таблицы ключей
идея перестраивать не все а только часть
используется кольцо значений и выделение зон для каждлого сервера
### решения
компонент секционирования данных в БД Dynamo от Amazon
разбиение данных по кластеру в Apache Cassandra
система обмена сообщениями Discord
сеть доставки содержимого Akamai
сетевой балансировщик нагрузки Maglev
***
## ХРАНИЛИЩЕ ТИПА «КЛЮЧ–ЗНАЧЕНИЕ»
### Теорема CAP - только 2 из 3х возможны
- Согласованность. 
  Означает, что все клиенты одновременно видят одни и те же данные, к какому бы узлу они ни подключились.
- Доступность. 
  Означает, что любой клиент, запрашивающий данные, получает ответ, даже если некоторые из узлов недоступны.	
- Устойчивость к секционированию. 
  Секционирование свидетельствует о нарушении связи между двумя узлами. 
  Устойчивость к секционированию означает, что система продолжает работать вопреки нарушению связи в сети.	

### Решаемые вопросы
- секционирование данных - Согласованное хеширование	
- репликация данных - дублирование на разных серверах и датацентрах
- согласованность - кворум на запись
- устранение несогласованности - самые последние записаннные данные возвращаем или вообще не важно
- обработка сбоев - gossip protocol (пренцип алайвов но со с передачей счетчиков)
- диаграмма архитектуры системы;
  Клиенты взаимодействуют с хранилищем типа «ключ–значение» через простые API: get(ключ) и put(ключ, значение)
  Координатор — это узел, который выступает прокси-сервером между клиентом и хранилищем. 
    И делает запросы к репликам.
    Какждые узел может быть координатором
  Узлы распределяются по кольцу с использованием согласованного хеширования.
  маршрут записи и маршрут чтения
  тут вообще куча всего включая SSTable и сброс на диск и тд
